<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Теоретическая часть</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Playfair+Display:wght@400;600;700&family=Rajdhani:wght@300;400;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Playfair Display', serif;
            background: #0a0c0f;
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow-x: hidden;
        }
        
        /* Анимированный фон */
        .animated-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
            opacity: 0.15;
        }
        
        .floating-object {
            position: absolute;
            filter: drop-shadow(0 0 20px rgba(102, 176, 255, 0.3));
            animation: float 20s infinite linear;
        }
        
        @keyframes float {
            0% {
                transform: translateY(100vh) rotate(0deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-20vh) rotate(360deg);
                opacity: 0;
            }
        }
        
        .object1 { left: 5%; animation-duration: 25s; }
        .object2 { left: 25%; animation-duration: 30s; }
        .object3 { left: 45%; animation-duration: 22s; }
        .object4 { left: 65%; animation-duration: 28s; }
        .object5 { left: 85%; animation-duration: 35s; }
        
        /* Градиентный оверлей */
        .gradient-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 30% 50%, rgba(102, 176, 255, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 70% 30%, rgba(255, 170, 102, 0.1) 0%, transparent 50%);
            z-index: -1;
            animation: gradientShift 15s ease-in-out infinite;
        }
        
        @keyframes gradientShift {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        
        .container {
            max-width: 1300px;
            width: 100%;
            position: relative;
            z-index: 10;
            backdrop-filter: blur(10px);
            background: rgba(10, 12, 15, 0.7);
            border-radius: 60px;
            padding: 50px;
            border: 1px solid rgba(102, 176, 255, 0.2);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 3.5rem;
            font-weight: 900;
            margin-bottom: 40px;
            text-align: center;
            background: linear-gradient(135deg, #66b0ff, #8a6eff, #ffaa66);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(102, 176, 255, 0.5);
            letter-spacing: 4px;
            animation: titleGlow 3s ease-in-out infinite;
            position: relative;
        }
        
        h1::after {
            content: '';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 3px;
            background: linear-gradient(90deg, transparent, #66b0ff, #ffaa66, #66b0ff, transparent);
            animation: lineMove 3s linear infinite;
        }
        
        @keyframes titleGlow {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(102, 176, 255, 0.5)); }
            50% { filter: drop-shadow(0 0 40px rgba(255, 170, 102, 0.5)); }
        }
        
        @keyframes lineMove {
            0% { background-position: -200px 0; }
            100% { background-position: 200px 0; }
        }
        
        .back-btn {
            background: rgba(45, 55, 72, 0.8);
            border: 2px solid #4a5568;
            color: #e0e0e0;
            padding: 12px 30px;
            font-size: 1.1rem;
            border-radius: 30px;
            cursor: pointer;
            margin-bottom: 30px;
            display: inline-block;
            backdrop-filter: blur(5px);
            transition: all 0.3s;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            letter-spacing: 1px;
        }
        
        .back-btn:hover {
            background: #4a5568;
            border-color: #66b0ff;
            transform: translateX(-5px);
            box-shadow: 0 5px 15px rgba(102, 176, 255, 0.3);
        }
        
        .back-btn:active {
            transform: scale(0.95);
        }
        
        /* Стили для кнопок */
        .theory-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin: 40px 0;
        }
        
        .theory-btn {
            position: relative;
            background: linear-gradient(135deg, rgba(26, 32, 44, 0.9), rgba(45, 55, 72, 0.9));
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            border-image: linear-gradient(135deg, #66b0ff, #ffaa66);
            border-image-slice: 1;
            color: #e0e0e0;
            padding: 20px 40px;
            font-size: 1.3rem;
            font-weight: 600;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.4s;
            min-width: 250px;
            overflow: hidden;
            z-index: 1;
            font-family: 'Orbitron', sans-serif;
            letter-spacing: 1px;
        }
        
        .theory-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 176, 255, 0.2), transparent);
            transition: left 0.6s;
            z-index: -1;
        }
        
        .theory-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(102, 176, 255, 0.4);
            border-color: #66b0ff;
            color: #fff;
        }
        
        .theory-btn:hover::before {
            left: 100%;
        }
        
        .theory-btn:active {
            transform: translateY(-2px) scale(0.98);
        }
        
        .submenu {
            margin: 30px 0;
            display: none;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }
        
        .submenu-btn {
            background: rgba(55, 65, 81, 0.8);
            border: 2px solid #4a5568;
            color: #e0e0e0;
            padding: 15px 30px;
            font-size: 1.1rem;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            letter-spacing: 1px;
        }
        
        .submenu-btn:hover {
            background: #4b5563;
            border-color: #ffaa66;
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(255, 170, 102, 0.3);
        }
        
        .submenu-btn:active {
            transform: scale(0.95);
        }
        
        /* Стили для контента */
        .content-card {
            background: linear-gradient(135deg, rgba(26, 32, 44, 0.8), rgba(45, 55, 72, 0.8));
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            border-image: linear-gradient(135deg, #66b0ff, #ffaa66);
            border-image-slice: 1;
            border-radius: 30px;
            padding: 40px;
            margin: 30px auto;
            max-width: 1000px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.4), 0 0 30px rgba(102, 176, 255, 0.2);
            position: relative;
            overflow: hidden;
            display: none;
        }
        
        .content-card.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .content-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(102, 176, 255, 0.1) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .content-text {
            font-family: 'Playfair Display', serif;
            font-size: 1.2rem;
            line-height: 1.8;
            color: #f0f4fa;
            position: relative;
            z-index: 2;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .content-text p {
            margin-bottom: 20px;
        }
        
        .content-text ul, .content-text ol {
            margin: 20px 0;
            padding-left: 30px;
        }
        
        .content-text li {
            margin-bottom: 12px;
            position: relative;
            list-style-type: none;
        }
        
        .content-text li::before {
            content: '▹';
            color: #ffaa66;
            position: absolute;
            left: -25px;
            font-size: 1.3rem;
            text-shadow: 0 0 10px #ffaa66;
        }
        
        .section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            font-weight: 700;
            margin: 40px 0 20px;
            background: linear-gradient(135deg, #66b0ff, #ffaa66);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: inline-block;
        }
        
        .section-title:first-of-type {
            margin-top: 0;
        }
        
        .highlight-block {
            background: rgba(102, 176, 255, 0.1);
            border-left: 5px solid #ffaa66;
            padding: 25px;
            margin: 30px 0;
            border-radius: 0 20px 20px 0;
            font-size: 1.2rem;
            color: #e0e0e0;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .highlight-block::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 100px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 170, 102, 0.1));
        }
        
        .law-number {
            display: inline-block;
            background: linear-gradient(135deg, #66b0ff, #ffaa66);
            color: #0a0c0f;
            padding: 5px 15px;
            border-radius: 30px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            margin-right: 15px;
            font-size: 1.1rem;
        }
        
        .footer {
            margin-top: 60px;
            color: #718096;
            font-size: 1rem;
            border-top: 1px solid rgba(102, 176, 255, 0.2);
            padding-top: 25px;
            text-align: center;
            width: 100%;
            font-family: 'Rajdhani', sans-serif;
        }
        
        .footer p {
            margin: 8px 0;
            font-weight: 300;
            letter-spacing: 1px;
        }
        
        .date {
            color: #ffaa66;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .glow-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #66b0ff;
            border-radius: 50%;
            opacity: 0.5;
            animation: particleFloat 10s infinite linear;
        }
        
        @keyframes particleFloat {
            0% {
                transform: translateY(0) translateX(0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateY(-100px) translateX(100px);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Анимированный фон -->
    <div class="animated-background">
        <svg class="floating-object object1" width="150" height="150" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="2" y="2" width="20" height="16" rx="2" stroke="#66b0ff" stroke-width="1.5"/>
            <circle cx="12" cy="10" r="2" fill="#ffaa66"/>
        </svg>
        
        <svg class="floating-object object2" width="120" height="120" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M4 20L20 20" stroke="#ffaa66" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M12 4L12 16" stroke="#ffaa66" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
        
        <svg class="floating-object object3" width="130" height="130" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M4 6L20 6" stroke="#66b0ff" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M4 12L20 12" stroke="#66b0ff" stroke-width="1.5" stroke-linecap="round"/>
        </svg>
        
        <svg class="floating-object object4" width="140" height="140" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="4" y="2" width="16" height="20" rx="2" stroke="#ffaa66" stroke-width="1.5"/>
            <circle cx="12" cy="8" r="1" fill="#66b0ff"/>
        </svg>
    </div>
    
    <div class="gradient-overlay"></div>
    
    <div class="container">
        <button class="back-btn" onclick="location.href='/'">← НА ГЛАВНУЮ</button>
        
        <h1>ТЕОРЕТИЧЕСКАЯ ЧАСТЬ</h1>
        
        <div class="theory-buttons">
            <button class="theory-btn" onclick="toggleSubmenu('principles')">ПРИНЦИПЫ ФИЗИКИ</button>
        </div>
        
        <div id="principles" class="submenu">
            <button class="submenu-btn" onclick="showContent('newton1')">ЗАКОНЫ НЬЮТОНА</button>
            <button class="submenu-btn" onclick="showContent('gravity')">ГРАВИТАЦИЯ</button>
            <button class="submenu-btn" onclick="showContent('optimization')">ОПТИМИЗАЦИЯ</button>
        </div>
        
        <!-- Контент: Законы Ньютона -->
        <div id="newton1" class="content-card">
            <div class="content-text">
                <div class="section-title">ПЕРВЫЙ ЗАКОН НЬЮТОНА (ЗАКОН ИНЕРЦИИ)</div>
                <p>Тело остаётся в покое или движется равномерно прямолинейно, пока на него не подействует внешняя сила.</p>
                
                <div class="highlight-block">
                    <strong>В игровом мире это означает:</strong>
                </div>
                
                <ul>
                    <li>Объект не начнёт двигаться сам по себе — нужен input игрока (например, нажатие клавиши W).</li>
                    <li>Объект не остановится мгновенно — будет постепенно замедляться.</li>
                    <li>Изменение направления требует приложения силы.</li>
                </ul>
                
                <p><em>Пример:</em> В играх персонаж или машина продолжают скользить после того, как игрок отпускает кнопку движения — это проявление инерции.</p>
                
                <div class="section-title">ПРИМЕНЕНИЕ В ИГРАХ</div>
                
                <p><span class="law-number">1</span> <strong>Физика движения:</strong> В играх, особенно в жанрах, где важна физика (например, гонки, платформеры, симуляторы), закон инерции помогает моделировать движение объектов. Если игрок управляет автомобилем, он должен учитывать инерцию: при резком повороте или торможении автомобиль будет продолжать двигаться в том направлении, в котором он двигался, пока не будет применена сила, чтобы изменить это состояние.</p>
                
                <p><span class="law-number">2</span> <strong>Динамика объектов:</strong> При взаимодействии объектов (например, столкновения) инерция помогает определить, как они будут реагировать. Например:</p>
                <ul>
                    <li>Если два объекта сталкиваются, их масса и скорость определяют, как они будут двигаться после столкновения.</li>
                    <li>Легкий объект может отскочить от тяжелого с меньшей скоростью, в то время как тяжелый объект будет двигаться дальше.</li>
                </ul>
                
                <p><span class="law-number">3</span> <strong>Управление персонажем:</strong> При управлении персонажем инерция может быть использована для создания более плавного и реалистичного движения. Например:</p>
                <ul>
                    <li>Персонаж может продолжать двигаться вперед даже после того, как игрок отпустил кнопку движения.</li>
                    <li>Добавление замедления при остановке (т.е. персонаж не останавливается мгновенно) создает ощущение веса и реалистичности.</li>
                </ul>
                
                <p><span class="law-number">4</span> <strong>Анимация и эффекты:</strong> Инерция также может влиять на анимации. Например:</p>
                <ul>
                    <li>При прыжке персонажа анимация может продолжаться даже после того, как игрок отпустил кнопку прыжка, чтобы показать эффект инерции.</li>
                    <li>В некоторых играх можно использовать "замедление времени" для визуализации инерции, когда объекты движутся медленнее и кажется, что они "плывут" в воздухе.</li>
                </ul>
                
                <p><span class="law-number">5</span> <strong>Физические движки:</strong> Современные игровые движки (такие как Unity или Unreal Engine) имеют встроенные физические движки, которые учитывают законы физики, включая закон инерции. Они позволяют разработчикам настраивать параметры массы, трения и других факторов, влияющих на движение объектов.</p>
                
                <div class="highlight-block">
                    <strong>Заключение:</strong> Закон инерции в играх помогает создать более реалистичное и увлекательное игровое окружение. Он позволяет игрокам взаимодействовать с миром так, как они ожидают в реальной жизни, что увеличивает погружение и удовольствие от игры.
                </div>
                
                <div class="section-title">ВТОРОЙ ЗАКОН НЬЮТОНА</div>
                <p>Связывает силу, массу и ускорение. Формула: <strong>F = m × a</strong>, где:</p>
                <ul>
                    <li>F — сила (в ньютонах);</li>
                    <li>m — масса объекта (в кг);</li>
                    <li>a — ускорение (в м/с²).</li>
                </ul>
                
                <p><span class="law-number">1</span> <strong>Сила и ускорение:</strong> Второй закон Ньютона позволяет разработчикам определять, как объекты в игре будут реагировать на различные силы. Например, если на объект действует сила (например, игрок толкает персонажа), его ускорение будет зависеть от этой силы и массы объекта. В играх это может быть использовано для создания механик, где игроки могут взаимодействовать с окружающей средой (например, толкать или тянуть объекты).</p>
                
                <p><span class="law-number">2</span> <strong>Динамика движения:</strong> При расчете движения объектов в игре важно учитывать, как силы влияют на их скорость и направление. Например, если персонаж прыгает, сила, приложенная к нему (например, сила тяжести), будет влиять на его вертикальное ускорение. На основе этого можно рассчитать, как высоко и далеко он прыгнет.</p>
                
                <p><span class="law-number">3</span> <strong>Управление персонажем:</strong> Второй закон Ньютона может быть использован для управления персонажем. Например, при нажатии кнопки вперед игрок может создать силу, которая будет двигать персонажа вперед с определенным ускорением. Если игрок отпускает кнопку, сила прекращается, и персонаж будет замедляться из-за трения или других факторов.</p>
                
                <div class="highlight-block">
                    <strong>Заключение:</strong> Второй закон Ньютона является основополагающим для создания реалистичной физики в играх. Он позволяет разработчикам моделировать движение объектов и их взаимодействие с окружающей средой, что делает игровой процесс более увлекательным и правдоподобным.
                </div>
                
                <div class="section-title">ТРЕТИЙ ЗАКОН НЬЮТОНА</div>
                
                <p><span class="law-number">1</span> <strong>Столкновения и взаимодействия:</strong> Когда два объекта сталкиваются, третий закон Ньютона объясняет, что силы, действующие на них, равны по величине и противоположны по направлению. Это позволяет разработчикам моделировать реалистичные столкновения между персонажами, транспортными средствами или другими объектами, а также определять, как объекты будут двигаться после столкновения, исходя из их масс и скоростей.</p>
                
                <p><span class="law-number">2</span> <strong>Движение персонажей:</strong> Когда персонаж прыгает или толкает объект, он оказывает силу на землю или объект. В ответ на это земля оказывает равную и противоположную силу на персонажа, что позволяет ему подниматься или двигаться. Например, при прыжке персонаж отталкивается от земли (действие), а земля отталкивает его вверх (противодействие).</p>
                
                <p><span class="law-number">3</span> <strong>Силы в окружающей среде:</strong> Третий закон Ньютона также применяется к взаимодействиям с окружающей средой. Когда игрок стреляет из оружия, пороховые газы создают силу, которая выталкивает пулю вперед (действие), и оружие испытывает отдачу (противодействие). Это может быть реализовано в игре через механики отдачи, которые влияют на прицеливание и управление оружием.</p>
                
                <p><span class="law-number">4</span> <strong>Физические симуляции:</strong> В играх с физическими симуляциями третий закон Ньютона помогает создать правдоподобные взаимодействия между объектами. Например, если один объект толкает другой, оба объекта будут двигаться в зависимости от их масс и направлений действия сил. Это позволяет создавать сложные системы взаимодействий, такие как разрушения или динамические сцены.</p>
                
                <div class="highlight-block">
                    <strong>Заключение:</strong> Третий закон Ньютона является ключевым для создания реалистичных взаимодействий в играх. Он помогает разработчикам моделировать физические эффекты, обеспечивать правдоподобное движение объектов и создавать увлекательный игровой процесс. Использование этого закона делает игровые механики более интуитивными и понятными для игроков.
                </div>
            </div>
        </div>
        
        <!-- Контент: Гравитация -->
        <div id="gravity" class="content-card">
            <div class="content-text">
                <div class="section-title">РЕАЛИЗАЦИЯ ГРАВИТАЦИИ В ИГРАХ</div>
                <p>Реализация гравитации в играх — это важный аспект физической симуляции, который помогает создать реалистичное поведение объектов и персонажей.</p>
                
                <div class="section-title">ОСНОВНЫЕ КОНЦЕПЦИИ ГРАВИТАЦИИ</div>
                <ul>
                    <li><strong>Сила гравитации:</strong> Гравитация обычно моделируется как постоянная сила, действующая на объекты вниз по направлению к центру планеты или другого небесного тела. В большинстве игр эта сила обозначается как <strong>F = m ⋅ g</strong>, где F — сила, m — масса объекта, а g — ускорение свободного падения (обычно около 9.81 м/с² на Земле).</li>
                    <li><strong>Ускорение:</strong> Гравитация приводит к постоянному ускорению объектов. Это означает, что скорость объекта будет увеличиваться с течением времени, если на него не действуют другие силы.</li>
                </ul>
                
                <div class="section-title">МОДЕЛИРОВАНИЕ ГРАВИТАЦИИ</div>
                <ul>
                    <li><strong>Физические движки:</strong> Многие игры используют физические движки (например, Unity с PhysX, Unreal Engine с Chaos Physics), которые уже включают в себя реализацию гравитации. Разработчики могут настроить параметры гравитации в движке, чтобы добиться нужного эффекта.</li>
                    <li><strong>Пользовательская реализация:</strong> В некоторых случаях разработчики могут реализовать собственную систему гравитации. Это может быть сделано путем обновления позиции объекта в каждом кадре с учетом силы гравитации:</li>
                </ul>
                
                <div style="background: #1a1e24; border-radius: 15px; padding: 20px; margin: 20px 0; font-family: 'Courier New', monospace; border: 1px solid #66b0ff;">
                    <code style="color: #ffaa66;">
# Пример на Python<br>
gravity = -9.81  # Ускорение свободного падения<br>
time_step = 0.016  # Время между кадрами (примерно 60 FPS)<br><br>
# Обновление скорости и позиции<br>
velocity += gravity * time_step<br>
position += velocity * time_step
                    </code>
                </div>
                
                <div class="section-title">ОБРАБОТКА СТОЛКНОВЕНИЙ</div>
                <p>Гравитация часто взаимодействует со столкновениями:</p>
                <ul>
                    <li><strong>Сопротивление:</strong> Когда объект сталкивается с землей или другой поверхностью, необходимо учитывать силу реакции (третий закон Ньютона). Если объект падает и достигает поверхности, его скорость может быть сброшена до нуля (или изменена), и он может начать двигаться по поверхности.</li>
                    <li><strong>Динамика движения:</strong> Объекты могут скользить, прыгать или отскакивать от поверхности в зависимости от их физических свойств (например, коэффициента трения).</li>
                </ul>
                
                <div class="section-title">НАСТРОЙКА И ПАРАМЕТРЫ</div>
                <ul>
                    <li><strong>Настройки гравитации:</strong> В зависимости от игрового мира, параметры гравитации могут варьироваться. Например, в фантастических играх или играх с космической тематикой можно использовать низкую или даже отрицательную гравитацию для создания уникальных механик.</li>
                    <li><strong>Локальная гравитация:</strong> В некоторых играх может быть реализована локальная гравитация, которая изменяется в зависимости от положения игрока или объектов. Это может быть полезно в уровнях с изменяющейся геометрией или в играх с платформами.</li>
                </ul>
                
                <div class="section-title">ЭФФЕКТЫ И ВИЗУАЛИЗАЦИЯ</div>
                <ul>
                    <li><strong>Анимация и визуальные эффекты:</strong> Для реалистичного отображения гравитации важно также учитывать анимацию объектов при падении или прыжках. Эффекты, такие как пыль при приземлении или растяжение объектов при падении, могут усилить восприятие гравитации.</li>
                </ul>
                
                <div class="highlight-block">
                    <strong>Заключение:</strong> Реализация гравитации в играх — это сочетание физики, математики и визуальных эффектов. Правильная настройка и моделирование гравитации помогают создать увлекательный и реалистичный игровой опыт для игроков.
                </div>
            </div>
        </div>
        
        <!-- Контент: Оптимизация -->
        <div id="optimization" class="content-card">
            <div class="content-text">
                <div class="section-title">ОПТИМИЗАЦИЯ ФИЗИКИ В ИГРАХ</div>
                <p>Оптимизация физики в играх — это важный аспект разработки, который позволяет обеспечить плавную работу игры даже при сложных физических симуляциях и большом количестве объектов.</p>
                
                <div class="section-title">ОСНОВНЫЕ МЕТОДЫ ОПТИМИЗАЦИИ</div>
                
                <p><span class="law-number">1</span> <strong>Использование физического движка:</strong> Многие современные игры используют готовые физические движки (например, Unity с PhysX, Unreal Engine с Chaos Physics), которые уже оптимизированы для работы с физическими расчетами. Эти движки используют различные алгоритмы и структуры данных для эффективного управления физикой.</p>
                
                <p><span class="law-number">2</span> <strong>Упрощение моделей:</strong></p>
                <ul>
                    <li><strong>Упрощенные коллайдеры:</strong> Вместо использования сложных 3D-моделей для расчета столкновений, можно применять упрощенные коллайдеры (например, сферы, коробки или капсулы). Это значительно уменьшает вычислительную нагрузку.</li>
                    <li><strong>LOD для физики:</strong> Использование различных уровней детализации (LOD) для физических объектов позволяет уменьшить количество расчетов на дальних расстояниях.</li>
                </ul>
                
                <p><span class="law-number">3</span> <strong>Динамическое управление физикой:</strong></p>
                <ul>
                    <li><strong>Состояния объектов:</strong> Объекты могут переключаться между активным и неактивным состоянием в зависимости от их роли в игре. Например, объекты, которые не находятся в поле зрения игрока или не взаимодействуют с ним, могут быть отключены от физического расчета.</li>
                    <li><strong>Симуляция по мере необходимости:</strong> Физические расчеты могут выполняться только для объектов, которые находятся в непосредственной близости к игроку или другим активным объектам.</li>
                </ul>
                
                <p><span class="law-number">4</span> <strong>Снижение частоты обновления:</strong> Физические расчеты могут выполняться с меньшей частотой, чем рендеринг. Например, обновление физики может происходить 30 раз в секунду, в то время как графика рендерится 60 раз в секунду.</p>
                
                <p><span class="law-number">5</span> <strong>Использование многопоточности:</strong> Современные процессоры имеют несколько ядер, и использование многопоточности для распределения нагрузки физических расчетов может значительно повысить производительность. Это позволяет выполнять расчеты для различных объектов параллельно.</p>
                
                <p><span class="law-number">6</span> <strong>Оптимизация алгоритмов:</strong></p>
                <ul>
                    <li><strong>Специальные алгоритмы:</strong> Использование эффективных алгоритмов для расчета столкновений и других физических взаимодействий, таких как алгоритмы пространственного деления (например, деревья BSP или Octree), может значительно ускорить вычисления.</li>
                    <li><strong>Кэширование результатов:</strong> Кэширование часто используемых результатов (например, результатов столкновений) может снизить количество необходимых расчетов.</li>
                </ul>
                
                <p><span class="law-number">7</span> <strong>Упрощение физических симуляций:</strong></p>
                <ul>
                    <li><strong>Сниженная точность:</strong> В некоторых случаях можно уменьшить точность физических расчетов, например, использовать приближенные методы вместо точных.</li>
                    <li><strong>Системы частиц:</strong> Для некоторых эффектов (например, взрывов или дыма) можно использовать системы частиц вместо полной физической симуляции объектов.</li>
                </ul>
                
                <p><span class="law-number">8</span> <strong>Профилирование и тестирование:</strong></p>
                <ul>
                    <li><strong>Профилирование производительности:</strong> Регулярное профилирование игры позволяет выявить узкие места в производительности и оптимизировать наиболее затратные операции.</li>
                    <li><strong>Тестирование на разных устройствах:</strong> Оптимизация должна учитывать различные платформы и устройства, чтобы обеспечить стабильную работу на всех целевых устройствах.</li>
                </ul>
                
                <div class="highlight-block">
                    <strong>Заключение:</strong> Оптимизация физики в играх — это комплексный процесс, который требует учета множества факторов. Использование готовых решений, упрощение моделей и расчетов, а также применение современных технологий и алгоритмов позволяют разработчикам создавать более производительные и отзывчивые игровые приложения.
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>Создали студенты Томского Техникума Информационных Технологий 452 группы Строганов Максим и Мартыненко Степан</p>
            <p class="date">2026 год</p>
        </div>
    </div>
    
    <script>
        function toggleSubmenu(id) {
            const submenu = document.getElementById(id);
            if (submenu.style.display === 'flex') {
                submenu.style.display = 'none';
            } else {
                submenu.style.display = 'flex';
            }
        }
        
        function showContent(id) {
            // Скрываем все карточки
            document.querySelectorAll('.content-card').forEach(card => {
                card.classList.remove('active');
            });
            
            // Показываем выбранную
            document.getElementById(id).classList.add('active');
            
            // Скрываем подменю после выбора
            document.getElementById('principles').style.display = 'none';
        }

        // Декоративные частицы
        function createParticles() {
            const particlesContainer = document.createElement('div');
            particlesContainer.style.position = 'fixed';
            particlesContainer.style.top = '0';
            particlesContainer.style.left = '0';
            particlesContainer.style.width = '100%';
            particlesContainer.style.height = '100%';
            particlesContainer.style.pointerEvents = 'none';
            particlesContainer.style.zIndex = '5';
            
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'glow-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 10 + 's';
                particle.style.animationDuration = 15 + Math.random() * 10 + 's';
                particlesContainer.appendChild(particle);
            }
            
            document.body.appendChild(particlesContainer);
        }
        
        createParticles();
    </script>
</body>
</html>